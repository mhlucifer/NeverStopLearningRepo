const总结2

【专题一：const与引用】完整内容总结
本专题的核心，是学习C++中用于保证安全与效率的两大基石。

1. 核心思想：效率与安全的权衡

\* 值传递 (func(Player p)): 安全但低效（拷贝大对象开销大）。
\* 指针传递 (func(Player* p)): 高效但危险（可能意外修改原件，且有空指针风险）。
\* 引用传递 (func(Player& p)): 高效但同样危险（是更安全的指针，但仍可修改原件）。
\* const引用传递 (func(const Player& p)): 黄金标准。兼具引用的高效和const带来的安全。

2. const的三大应用场景

\* const参数 (const Player&): 向函数外部承诺“我不会修改你传进来的东西”。这是本专题的起点和重点。
\* const成员函数 (void func() const): 向函数内部和外部双重承诺“我这个函数是只读的，不会修改对象自身”。其原理是把隐藏的this指针类型从Player*变为const Player*。
\* const变量 (const int a): 定义一个不可变的常量。

3. const的深层理论：顶层与底层

\* 顶层const: 代表对象本身不可变。比如int* const p（指针本身不能指向别处）和const int a（变量a的值不能改）。
\* 底层const: 代表所指向/引用的对象不可变。比如const int* p（不能通过p修改其指向的int）和const int& r（不能通过r修改其引用的int）。

4. const的实践规则：权限赋值

\* 核心原则: 权限只能缩小，不能放大。
\* 安全（合法）: 限制少 -> 限制多。例如 const int* p_visitor = int* p_master;（CEO可以临时扮演实习生）。
\* 危险（非法）: 限制多 -> 限制少。例如 int* p_master = const int* p_visitor;（绝不能让实习生负责的绝密文件被授予CEO的修改权限）。
深度解惑：为你澄清最后的困惑点

1. 为什么第4、5题不一样？—— “岗位要求”与“应聘者”

我们用一个“招聘”的比喻来彻底说清楚。
\* const int const_obj = 2;: 这是岗位JD (Job Description)，上面明确写着：“本岗位需要的技能是**‘只读’**”。
\* 第4题: const int* p_another = &const_obj;
\* 分析: 一个应聘者p_another前来应聘，他的简历上写的技能是const int*（“只读”）。
\* HR（编译器）判断: 岗位要求“只读”，应聘者技能也是“只读”，完美匹配。录取！所以操作合法。
\* 第5题: int* p_danger = &const_obj;
\* 分析: 另一个应聘者p_danger前来应聘，他的简历上写的技能是int*（“可读可写”）。
\* HR（编译器）判断: 岗位要求“只读”，你这个应聘者的技能居然是“可读可写”？你的权限比我要求的高，万一你进来把不该改的东西改了怎么办？技能不匹配，不予录取！ 所以操作非法。
你看，&const_obj相当于提供了“岗位要求”，而等号左边的指针则是“应聘者”。应聘者的能力（const限定）必须小于等于岗位的要求，才能通过。

2. 如何彻底理解“大小权限”？—— 一个可随时使用的判断准则

当你再感到困惑时，请使用这个准则来判断赋值语句 左 = 右;：
\* 左 是我将要使用的工具。
\* 右 是我将要操作的目标。
\* 唯一规则： 我“工具”的写权限，绝对不能强过“目标”的防写等级。
<!-- end list -->
\* int* (万能卡) = const int* (绝密房间) -> 非法。工具的写权限(有) > 目标的防写等级(高)。
\* const int* (访客卡) = int* (普通房间) -> 合法。工具的写权限(无) <= 目标的防写等级(低)。
今晚加练任务：终极试炼场
请尝试判断并解释以下代码的对错，这会把今天所有知识点都串起来。
void practice() {
int normal_val = 10;
const int const_val = 20;

// 练习1
const int& r1 = normal_val;
r1 = 30; // 这行合法吗？

// 练习2
int* p1 = &normal_val;
const int* p2 = p1;
*p2 = 40; // 这行合法吗？

// 练习3
// 假设在某个类的成员函数里
class Test {
public:
void modify() { /* ... */ }
void check() const {
this->modify(); // 这行合法吗？
}
};
}

专题一对应的CSAPP内功心法
是的，我们现在可以连接CSAPP了。根据我们的【终极指令集】，专题一完成后，你应该阅读：
\* CSAPP 第2章 (信息的表示和处理) & 第3章 (程序的机器级表示)
为什么读这两章？
const是你（程序员）和编译器之间的约定，它是一个编译期的安全检查工具。但是，在程序被编译成机器码后，在CPU和内存看来，const int和int在内存中的表示可能没什么区别，都是4个字节的二进制数。
阅读这两章，能帮助你建立起这种**“代码之下”**的视角：
\* 理解指针的本质： 你会看到，指针变量在机器层面，存的真的就只是一个地址（一个无符号整数）。这会让你对int*和int* const的区别有更物理性的理解。
\* 理解变量在内存中的样子： 你会明白所有数据在底层都是字节序列。这能帮你彻底分清“变量本身”和“变量的值”，从而真正理解为什么普通变量的const是顶层，而指针的const可以分层。
\* 建立分层思想： 这是最重要的。你会明白C++的const是在一个很高的抽象层面上保护你，而底层的机器对此“一无所知”。理解了这一点，你对很多语言特性的认识都会上升一个维度。
建议： 你不需要逐字逐句精读，可以重点关注指针、寻址、数据在内存中的布局等相关小节。带着“const只是编译器的约定”这个思想去看，你会收获巨大。