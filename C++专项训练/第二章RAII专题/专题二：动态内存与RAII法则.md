【专题二：动态内存与RAII法则】今日学习内容详细复盘
我们今天的核心目标是彻底征服C++的动态内存管理。整个学习过程遵循“发现问题 -> 手动解决 -> 发现风险 -> 学习哲学 -> 升级武器”的路径。

1. 核心问题：为什么需要动态内存？

\* 起点： 我们认识到，像int arr[10];或我们之前MyString里的定长数组这样的栈内存，其大小在编译时就已固定，无法应对程序运行时才得知的未知数量的数据。
\* 需求： 为了实现像std::vector这样可以“动态增长”的容器，我们必须使用堆内存（Heap），它允许我们在程序运行时按需申请和释放任意大小的内存块。

2. 原始工具与风险：new 和 delete

\* “招式”： C++提供了两个最底层的操作符来直接管理堆内存：
\* new T[N]: 申请一块能容纳N个T类型对象的连续内存空间（数组）。
\* delete[]: 释放由new[]申请的内存。
\* 风险识别： 我们迅速发现了手动使用new/delete的巨大风险——它完全依赖程序员的细心。任何一次疏忽，如忘记delete、在delete前提前return、重复delete等，都会导致内存泄漏或程序崩溃。

3. C++的核心哲学：RAII (资源获取即初始化)

\* “心法”： 为了从根本上解决手动管理的风险，我们学习了C++资源管理的核心思想——RAII。
\* 原理： 将资源的生命周期与一个对象的生命周期绑定。
\* 在构造函数中获取资源（执行new）。
\* 在析构函数中释放资源（执行delete）。
\* 保证： 利用C++语言“栈上对象离开作用域时，其析构函数必被调用”的铁律，实现了资源的自动化、精准、无遗漏的释放。

4. 核心实践：从零锻造my_vector

这是我们将理论付诸实践的 crucible（熔炉）。
\* 数据成员： 我们确定了my_vector的核心数据结构：T* data_（指向堆内存的指针）、size_t size_（实际元素数量）、size_t capacity_（已分配的内存容量）。
\* 构造/析构： 我们编写了安全的默认构造函数（将指针初始化为nullptr）和负责释放内存的析构函数 (delete[] data_)。
\* 最复杂的逻辑——resize()： 我们亲手实现了push_back背后的扩容算法，并总结出其安全执行的四步/五步法：
\* 计算新容量（翻倍，处理0的边界情况）。
\* 分配新内存（new T[new_capacity]）。
\* 复制旧数据到新内存中。
\* 释放旧内存（delete[] old_data），这一步我们通过“临时指针”技巧保证了操作的安全性。
\* 更新数据指针和容量。

5. 终极武器：std::unique_ptr 与 std::move

在深刻体会了手动管理的痛苦后，我们升级了我们的制式装备。
\* std::unique_ptr<T[]>: 我们学习并使用了这个为独占所有权的动态数组量身定做的智能指针。
\* 自动化升级：
\* 析构自动化： 将data_类型换为unique_ptr后，~my_vector()析构函数可以完全清空，因为unique_ptr的析构函数会自动为我们调用delete[]。
\* resize逻辑简化： 复杂的“临时指针”和手动delete操作被一行优雅的移动赋值所取代：data_ = std::move(new_data);。
\* 背后的原理（深度挖掘）：
\* 所有权（Ownership）： 理解了unique_ptr的“独占”特性，并通过= delete语法了解到它是如何在编译期被强制执行的。
\* 移动语义（Move Semantics）： 明白了std::move的本质是一个到“右值引用”的类型转换，它授权编译器调用被特殊定义的“移动构造函数”和“移动赋值运算符”，从而实现高效的资源所有权转移，而非昂贵的拷贝。
今日总结： 您今天不仅学会了如何在C++中管理动态内存，更重要的是，您建立了一套完整的现代C++思维模式：从理解问题本质，到应用语言哲学（RAII），再到利用高级工具（智能指针、移动语义）优雅地解决问题。
请您利用白天时间仔细回顾这份总结。今晚，我们将把理论彻底转化为您的代码能力。