### C语言总结

本文旨在梳理自己在复习C语言过程中学到的一些概念性和新的内容，并且用自己的语言说明概念和一些案例以便未来查阅和帮助同样复习C语言的人进行查阅。

#### 专题一：指针相关

1. ##### 指针

什么是指针？我的理解是指针就是一个**存储内存地址的变量**，根据位的不同，指针也会发生变化，一般是4字节或者8字节。指针变量本身的大小只由系统的寻址能力决定。但是不同的是，在进行解引用指针时，它所指向的对象或者值会根据大小不同而不同。

这里可以形象的把值和指针比喻成一个快递来理解，假设值是一个包裹，指针就可以当成单号，单号的大小都是一致的，只取决于仓库的大小，比如有些仓库需要存储的东西更多，就用8字节的，有些小，就用4字节的。指针类型即为一种说明，告诉编译器，这个值需要用几个字节进行搬运，比如int类型就是4字节，char类型就是1字节。这里用一句话说明，指针是内存的快递单号，单号大小固定，但类型决定如何拆箱。

根据这里的思路，我们可以用一个例子来说明：

```c
int a = 0x12345678;      // 一个包裹，内容是 0x12345678
char *p = (char *)&a;    // 假装它是1字节的小件（只看第一个格子）

printf("%x", *p);        // 取出第一个"格子"的值
// 小端系统输出：0x78（就像从大包裹里只拿了最左边的小盒子）
```

这里我们利用了指针的概念对其进行强转，使得我们对本身是int类型的地址a，让编译器把他看成字节类型，以此只取出第一个字节部分。如果用比喻来说明这里，就像把一个大包裹（`int`）的快递单号强行改成小件（`char`）单号，结果只能取出包裹的第一小块内容。

2. ##### 数组指针，指针数组

对于这两个是初学经常容易混淆的概念。我的记忆方式是谁在后面，它就是什么类型，比如数组指针就是一种指针，指针数组就是一种数组。

**数组指针，简单来说，就是它是一个指针类型，指向的值是数组**

**指针数组，简单来说，就是它是一个数组，里面存的值是指针**

对于这两种类型，他们的一般表示方式为:

**数组指针 :   数据类型 (* 数组名)[数组长度]** 

**指针数组 :   数据类型 * 数组名[数组长度]**    

首先来说数组指针，数组指针根据课程的讲解，一般在操作多维数组，比如传递整个数组行时使用。比如：

```c
int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
int (*p)[3] = matrix;  // p指向matrix的第一行（一个包含3个int的数组）

printf("%d", p[1][2]);  // 输出: 6（访问第二行第三列）
```

这里的p[1] [2] 可以理解为C语言中的一种语法糖，其本质是  * (*(p + 1) + 2)，另外这里matrix是地址首元素的地址，这里他退化成了指针，这个内容我将在后文函数指针部分进行解释。

其次是指针数组，指针数组一般会用来管理多个字符串（字符串表），比如：

```c
char *fruits[] = {"Apple", "Banana", "Cherry"}; // 每个元素指向常量字符串
for (int i = 0; i < 3; i++) {
    printf("%s\n", fruits[i]); 
}
```

如果比喻来说，就像是一个**电话号码簿**，每个条目（指针）指向不同人的联系方式（字符串），而不是把所有联系方式拼在一起存储。

##### 3.函数指针

函数指针，和上面的理解方式一样，函数指针就是一个指针，它指向的对象是一个函数。这就是他的概念，很好理解，但是他能引出的方法和与数组指针，指针数组等知识组合以后就变得相对复杂。所以这里尝试由简单到复杂的来展示函数指针及其相关的运用方式。

函数指针 ：  返回值类型 *(指针名)（参数列表） 

```c
int add(int a, int b) { return a + b; }
int (*funcPtr)(int, int) = add;  // funcPtr指向add函数
```

这就是他的基本概念。但是他的应用场景非常多

> 第一个场景：动态调用不同函数

```c
int subtract(int a, int b) { return a - b; }

int main() {
    int (*operation)(int, int);  // 声明函数指针
    operation = add;      // 指向加法
    printf("%d\n", operation(3, 2));  // 输出5

    operation = subtract; // 改为指向减法
    printf("%d\n", operation(3, 2));  // 输出1
    return 0;
}
```

简单的说，这里就是通过更换指针指向的函数，实现不同的功能，有点类似万能指针的概念，也可以类比成面向对象里的多态，当然这里是简单的多态（多态是在运行时编译并且自动的进行隐式转换）。



> 第二个场景：回调函数

回调函数这里刚开始会觉得有点绕，这里我尝试用自己的语言循序渐进的解释这个函数的作用

先看一个例子

```c
// ① 定义回调函数类型
typedef void (*Callback)(int);

// ② 接收回调的函数
void doSomething(int data, Callback cb) {
    printf("处理数据: %d\n", data);
    cb(data * 2);  // 处理完成后调用回调
}

// ③ 实际回调函数
void myCallback(int result) {
    printf("回调结果: %d\n", result);
}

int main() {
    doSomething(10, myCallback);  // 传递回调函数
    return 0;
}
```

1.首先typedef void (*Callback)(int) 这个可以理解成一种声明，简单的说就是以后见到callback这个东西都把看成一个函数指针，他的返回值是void，参数是int类型。正如上文所提到的，函数指针我们可以把它看成一种万能指针，这里相当于创建了一个框，这个框内可以放入任意返回值与参数和它相同的函数

2.doSomething函数的参数有data和刚刚的函数指针类型cb，这说明对于dosomething这个函数来说，其第二个参数可以填入任意返回值与参数和它相同的函数（同1中的概念，看成万能指针）

3.myCallback函数，注意这个函数的返回值和参数，是不是发现它和函数指针的一模一样，这时候，我们如果我们把他当作doSomething函数的参数传入（这里还有个小tips，当函数名作为参数传递时，会退化成指针，即函数退化成函数指针），这时候就会调用他的函数内容。

4.调用doSomething()，就会发生如上的内容，简单的说回调函数和第一个例子没有太本质区别，都是将函数指针看作一个万能指针（我们比喻成框）,任何相似的函数都可以等于（赋值）或者作为参数等于（传递赋值）。

那么回调函数有什么用呢，我的理解是之前函数的调用都是一种主动调用，而回调函数，类似与一种被动调用，就是将控制权交给被调用方，类似你做完通知我的机制。换句话说，因为调用函数的参数是不固定的，其参数值因为不同的函数会得到不同的结果，或者表现出不同的行为，而这些不同的结果和行为会影响到当前调用函数的结果和行为。

对于回调函数这个部分，我查询了一下相关概念，这里有一个我认为值得记住的设计理念：

- **框架代码（`simulateEvent`）不关心具体处理逻辑**
- **用户代码（`eventHandler`）实现具体行为**



> 第三个场景： 函数表（跳转表）

函数表这部分相对来说很好理解，其实就是利用函数指针数组来分别调用对应的函数

```c
void start() { printf("启动\n"); }
void stop() { printf("停止\n"); }
void (*commands[])() = {start, stop};

int main() {
    int cmd = 0; // 用户输入
    commands[cmd]();  // 调用对应函数
    return 0;
}
```

当然，函数指针数组也有一些优势，比如可以替代switch函数，相对更优雅

以上是函数指针的一些基础用法和实践，对于一些相对更加抽象的用法和高阶使用比如函数指针数组的数组，函数指针的结构体封装，函数指针的参数化，函数指针作为返回值等内容将会在后面慢慢总结





#### 专题二：结构体相关

##### 1.结构体

什么是结构体？其实我们可以把结构体当作一种自定义的数据类型，他和int double char的区别在于前者是复合类型，后者是标量类型，他需要我们自己去定义，我们也可以把它想象成一个收纳盒，这个盒子里可以分门别类地放置各种不同的物品（数据），而整个盒子有一个统一的名字。

举个例子：

```c
// 定义一个名为「Student」的收纳盒
struct Student {
    int id;           // 学号（整数）
    char name[20];    // 姓名（字符数组）
    float score;      // 成绩（浮点数）
};

// 根据蓝图创建具体的收纳盒
struct Student stu1; // 声明一个Student类型的变量stu1

// 初始化：向收纳盒里放入具体物品
struct Student stu2 = {20240001, "Alice", 95.5f};

//调用盒子中的东西
stu1.id = 20240002;
strcpy(stu1.name, "Bob");
stu1.score = 88.0f;

printf("ID: %d, Name: %s, Score: %.1f\n", stu1.id, stu1.name, stu1.score);
```

我们可以把struct理解成一个设计图，而声明出来的变量就是一个实体。同时我们通过.运算符来调用这个盒子里的东西。这个部分很好理解。



##### 2. 结构体与指针：指向收纳盒的“索引卡”

当结构体很大或需要在函数间高效传递时，我们不会直接搬运整个“收纳盒”，而是使用指针——即一张写着“收纳盒位置”的**索引卡**。(说明：这里涉及值传递和指针传递的区别，我们知道值传递是一种拷贝传递，而指针传递是地址传递，拷贝传递不会修改其本身，而地址传递因为直接指向的其本体，所以会被修改，我将在3里说明)

例子说明：

```c
struct Student stu = {20240003, "Charlie", 92.0f};
struct Student *pStu = &stu; // pStu是一张指向stu收纳盒的索引卡

// 通过索引卡访问收纳盒里的物品，需要使用->操作符
printf("ID: %d\n", pStu->id);   // 等价于 (*pStu).id
printf("Name: %s\n", pStu->name);
```



##### 3.结构体与函数：传递整个收纳盒还是索引卡？

> 值传递：函数会得到整个收纳盒的一个副本。在函数内修改副本，不会影响原来的盒子。

```c
void printStudent(struct Student s) { // 接收一个完整的副本
    printf("Score: %.1f\n", s.score);
}
// 优点：安全，原数据不受影响
// 缺点：复制大量数据时，效率低（盒子越大越慢）
```

> 指针传递（地址传递）：函数只得到一张索引卡。通过索引卡修改，会直接改变原来的收纳盒。

```c
void raiseScore(struct Student *pS, float amount) {
    pS->score += amount; // 根据地址直接修改原数据
}
raiseScore(&stu1, 5.0f); // stu1的分数被永久增加了5分
```

所以在实践中，一般都是用指针传递结构体，除非这个结构体足够小（其实可以忽略，尽量使用指针）



##### 4.结构体的一些使用场景

嵌套与柔性数组

结构体对齐：收纳盒的摆放艺术（内存对齐）

位段

结构体作为函数参数









联合体

字符串函数

动态分配